{"version":3,"sources":["hooks/use-dark-mode.js","hooks/use-local-storage.js","hooks/use-media.js","components/Toggle.js","components/Content.js","App.js","serviceWorker.js","index.js"],"names":["useDarkMode","_useLocalStorage","key","initialValue","_useState","useState","item","window","localStorage","getItem","JSON","parse","error","console","log","_useState2","Object","slicedToArray","storedValue","setStoredValue","value","valueToStore","Function","setItem","stringify","useLocalStorage","_useLocalStorage2","enabledState","setEnabledState","prefersDarkMode","queries","values","defaultValue","setValue","mediaQueryLists","map","q","matchMedia","getValue","index","findIndex","mql","matches","useEffect","handler","forEach","addListener","removeListener","useMedia","enabled","element","document","body","classList","add","remove","Toggle","_ref","darkMode","setDarkMode","react_default","a","createElement","className","type","onClick","id","checked","onChange","htmlFor","Content","App","_useDarkMode","_useDarkMode2","components_Toggle","components_Content","Boolean","location","hostname","match","ReactDOM","render","src_App","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.b34e1853.chunk.js","sourcesContent":["import { useEffect } from 'react';\nimport useLocalStorage from './use-local-storage';\nimport useMedia from './use-media';\n\nfunction useDarkMode() {\n  // Use our useLocalStorage hook to persist state through a page refresh.\n  // Read the recipe for this hook to learn more: usehooks.com/useLocalStorage\n  const [enabledState, setEnabledState] = useLocalStorage('dark-mode-enabled');\n\n  // See if user has set a browser or OS preference for dark mode.\n  // The usePrefersDarkMode hook composes a useMedia hook (see code below).\n  const prefersDarkMode = usePrefersDarkMode();\n\n  // If enabledState is defined use it, otherwise fallback to prefersDarkMode.\n  // This allows user to override OS level setting on our website.\n  const enabled =\n    typeof enabledState !== 'undefined' ? enabledState : prefersDarkMode;\n\n  // Fire off effect that add/removes dark mode class\n  useEffect(\n    () => {\n      const className = 'dark-mode';\n      const element = window.document.body;\n      if (enabled) {\n        element.classList.add(className);\n      } else {\n        element.classList.remove(className);\n      }\n    },\n    [enabled] // Only re-call effect when value changes\n  );\n\n  // Return enabled state and setter\n  return [enabled, setEnabledState];\n}\n\n// Compose our useMedia hook to detect dark mode preference.\n// The API for useMedia looks a bit weird, but that's because ...\n// ... it was designed to support multiple media queries and return values.\n// Thanks to hook composition we can hide away that extra complexity!\n// Read the recipe for useMedia to learn more: usehooks.com/useMedia\nfunction usePrefersDarkMode() {\n  return useMedia(['(prefers-color-scheme: dark)'], [true], false);\n}\n\nexport default useDarkMode;\n","import { useState } from 'react';\n\n// Code from https://usehooks.com/useLocalStorage\n\nexport default function useLocalStorage(key, initialValue) {\n  // State to store our value\n  // Pass initial state function to useState so logic is only executed once\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      // Get from local storage by key\n      const item = window.localStorage.getItem(key);\n      // Parse stored json or if none return initialValue\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      // If error also return initialValue\n      console.log(error);\n      return initialValue;\n    }\n  });\n\n  // Return a wrapped version of useState's setter function that ...\n  // ... persists the new value to localStorage.\n  const setValue = value => {\n    try {\n      // Allow value to be a function so we have same API as useState\n      const valueToStore =\n        value instanceof Function ? value(storedValue) : value;\n      // Save state\n      setStoredValue(valueToStore);\n      // Save to local storage\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      // A more advanced implementation would handle the error case\n      console.log(error);\n    }\n  };\n\n  return [storedValue, setValue];\n}\n","import { useEffect, useState } from 'react';\n\n// Code from https://usehooks.com/useMedia\n\n// Alternate hook that accepts a single query\nexport default function useMedia(queries, values, defaultValue) {\n    // State and setter for matched value\n    const [value, setValue] = useState(defaultValue);\n\n    // Array containing a media query list for each query\n    const mediaQueryLists = queries.map(q => window.matchMedia(q));\n\n    // State update function\n    const getValue = () => {\n        // Get index of first media query that matches\n        const index = mediaQueryLists.findIndex(mql => mql.matches);\n        // Return related value or defaultValue if none\n        return typeof values[index] !== 'undefined' ? values[index] : defaultValue;\n    };\n\n    useEffect(\n        () => {\n            // Set the initial value\n            setValue(getValue);\n\n            // Event listener callback\n            // By defining getValue outside of useEffect we ensure that it has ...\n            // ... current values of hook args (as this hook only run on mount/dismount).\n            const handler = () => setValue(getValue);\n\n            // Set a listener for each media query with above handler as callback.\n            mediaQueryLists.forEach(mql => mql.addListener(handler));\n\n            // Remove listeners on cleanup\n            return () => mediaQueryLists.forEach(mql => mql.removeListener(handler));\n        },\n        // eslint-disable-next-line\n        [] // Empty array ensures effect is only run on mount and unmount\n    );\n\n    return value;\n}\n","import React from 'react';\n\nconst Toggle = ({ darkMode, setDarkMode }) => (\n  <div className=\"dark-mode-toggle\">\n    <button type=\"button\" onClick={() => setDarkMode(false)}>\n      ☀\n    </button>\n    <span className=\"toggle-control\">\n      <input\n        className=\"dmcheck\"\n        id=\"dmcheck\"\n        type=\"checkbox\"\n        checked={darkMode}\n        onChange={() => setDarkMode(!darkMode)}\n      />\n      <label htmlFor=\"dmcheck\" />\n    </span>\n    <button type=\"button\" onClick={() => setDarkMode(true)}>\n      ☾\n    </button>\n  </div>\n);\n\nexport default Toggle;\n","import React from 'react';\n\nconst Content = ({ checked, onChange }) => (\n    <div className=\"content\">\n        <h1>What Are Hooks, Exactly?</h1>\n        <p>\n            To understand Hooks, we need to take a step back and think about code\n            reuse.\n    </p>\n        <p>\n            Today, there are a lot of ways to reuse logic in React apps. We can write\n            simple functions and call them to calculate something. We can also write\n            components (which themselves could be functions or classes). Components\n            are more powerful, but they have to render some UI. This makes them\n            inconvenient for sharing non-visual logic. This is how we end up with\n            complex patterns like render props and higher-order components. Wouldn’t\n            React be simpler if there was just one common way to reuse code instead of\n            so many?\n    </p>\n        <p>\n            Functions seem to be a perfect mechanism for code reuse. Moving logic\n            between functions takes the least amount of effort. However, functions\n            can’t have local React state inside them. You can’t extract behavior like\n            “watch window size and update the state” or “animate a value over time”\n            from a class component without restructuring your code or introducing an\n            abstraction like Observables. Both approaches hurt the simplicity that we\n            like about React.\n    </p>\n        <p>\n            Hooks solve exactly that problem. Hooks let you use React features (like\n            state) from a function — by doing a single function call. React provides a\n            few built-in Hooks exposing the “building blocks” of React: state,\n            lifecycle, and context.\n    </p>\n        <p>\n            Since Hooks are regular JavaScript functions, you can combine built-in\n            Hooks provided by React into your own “custom Hooks”. This lets you turn\n            complex problems into one-liners and share them across your application or\n            with the React community.\n    </p>\n    </div>\n);\n\nexport default Content;\n","import React from 'react';\nimport useDarkMode from './hooks/use-dark-mode';\nimport Toggle from './components/Toggle';\nimport Content from './components/Content';\nimport './App.scss';\n\nfunction App() {\n  const [darkMode, setDarkMode] = useDarkMode();\n\n  return (\n    <div>\n      <div className=\"navbar\">\n        <Toggle darkMode={darkMode} setDarkMode={setDarkMode} />\n      </div>\n      <Content />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}